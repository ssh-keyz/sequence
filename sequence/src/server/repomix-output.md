This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-21T02:02:18.026Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
config/
  database.ts
  index.ts
  livereload.ts
  session.ts
  socket.ts
  sockets.ts
constants/
  gameConfig.ts
db/
  games/
    index.ts
    sql.ts
  migrations/
    001_create_users.sql
  users/
    index.ts
    sql.ts
  connection.ts
  index.ts
  migrate.ts
middleware/
  auth.ts
  authentication.ts
  chat.ts
  error.ts
  index.ts
  tailwind-util.ts
models/
  game.ts
  user.ts
routes/
  game-middleware/
    broadcast-game-update.ts
    can-player-draw.ts
    index.ts
    is-players-turn.ts
  auth.ts
  chat.ts
  games.ts
  home.ts
  index.ts
  main-lobby.ts
  test.ts
socket/
  gameHandlers.ts
types/
  express-session.d.ts
  socket.ts
views/
  auth/
    login.ejs
    register.ejs
  games/
    game.ejs
    lobby.ejs
    templates.ejs
  partials/
    chat.ejs
    head.ejs
    menu.ejs
  home.ejs
  main-lobby.ejs
index.ts
```

# Repository Files

## File: config/database.ts
```typescript
import pgPromise from 'pg-promise';
import dotenv from 'dotenv';
// Load environment variables
dotenv.config();
const pgp = pgPromise({
  // Initialization options
  capSQL: true, // capitalize SQL queries
  // Add event handlers here
  error: (err, e) => {
    if (e.cn) {
      // Connection-related error
      console.error('Database connection error:', err);
    } else {
      // Query-related error
      console.error('Database query error:', err);
    }
  },
});
// Database connection configuration
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432', 10),
  database: process.env.DB_NAME || 'sequence_game',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD,
  max: 30, // Maximum number of connection pool clients
  idleTimeoutMillis: 30000, // How long a client is allowed to remain idle before being closed
};
// Create the database instance with a connection pool
const db = pgp(dbConfig);
// Test the connection
db.connect()
  .then((obj) => {
    console.log('Database connection successful');
    obj.done(); // success, release the connection
  })
  .catch((error) => {
    console.error('Database connection error:', error);
  });
export { db, pgp };
```

## File: config/index.ts
```typescript
export { default as configureLiveReload } from "./livereload";
export { default as configureSession } from "./session";
export { default as configureSocketIO } from "./sockets";
```

## File: config/livereload.ts
```typescript
import connectLiveReload from "connect-livereload";
import type { Express } from "express";
import livereload from "livereload";
const configureLiveReload = (app: Express, staticPath: string) => {
  if (process.env.NODE_ENV === "development") {
    const reloadServer = livereload.createServer();
    reloadServer.watch(staticPath);
    reloadServer.server.once("connection", () => {
      setTimeout(() => {
        reloadServer.refresh("/");
      }, 100);
    });
    app.use(connectLiveReload());
  }
};
export default configureLiveReload;
```

## File: config/session.ts
```typescript
import connectPgSimple from "connect-pg-simple";
import type { Express, RequestHandler } from "express";
import flash from "express-flash";
import session from "express-session";
let sessionMiddleware: RequestHandler | undefined = undefined;
export default (app: Express): RequestHandler => {
  if (sessionMiddleware === undefined) {
    sessionMiddleware = session({
      store: new (connectPgSimple(session))({
        createTableIfMissing: true,
        conObject: {
          host: process.env.DB_HOST || 'localhost',
          port: parseInt(process.env.DB_PORT || '5432', 10),
          database: process.env.DB_NAME || 'sequence_game',
          user: process.env.DB_USER || 'postgres',
          password: process.env.DB_PASSWORD || 'postgres'
        }
      }),
      secret: process.env.SESSION_SECRET!,
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: parseInt(process.env.SESSION_COOKIE_MAX_AGE || '86400000', 10)
      }
    });
    app.use(sessionMiddleware);
    app.use(flash());
  }
  return sessionMiddleware;
};
```

## File: config/socket.ts
```typescript
import { Server as HttpServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import { verify } from 'jsonwebtoken';
import { UserModel } from '../models/user';
export const configureSocketIO = (server: HttpServer) => {
  const io = new SocketServer(server, {
    cors: {
      origin: process.env.NODE_ENV === 'production'
        ? process.env.CORS_ORIGIN
        : 'http://localhost:3000',
      methods: ['GET', 'POST'],
      credentials: true
    }
  });
  // Global middleware for authentication
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      if (!token) {
        next(new Error('Authentication required'));
        return;
      }
      const decoded = verify(token, process.env.JWT_SECRET!) as { userId: string };
      const user = await UserModel.findById(decoded.userId);
      if (!user) {
        next(new Error('User not found'));
        return;
      }
      // Attach user data to socket
      socket.data.user = {
        id: user.id,
        username: user.username,
        email: user.email
        // Add any other properties needed
      };
      next();
    } catch (error) {
      next(new Error('Authentication failed'));
    }
  });
  // Set up game handlers
  setupGameHandlers(io);
  // Error handling
  io.on('error', (error) => {
    console.error('Socket.IO error:', error);
  });
  return io;
}; 
function setupGameHandlers(io: SocketServer<import("socket.io").DefaultEventsMap, import("socket.io").DefaultEventsMap, import("socket.io").DefaultEventsMap, any>) {
    throw new Error('Function not implemented.');
}
```

## File: config/sockets.ts
```typescript
import { Server } from "http";
import type { Express, RequestHandler } from "express";
import { Server as SocketIoServer, Socket } from "socket.io";
let io: SocketIoServer | undefined;
const bindSession = async (socket: Socket) => {
  const { request } = socket;
  const {
    user = { id: undefined },
    roomId,
    // @ts-expect-error TODO figure out the typing for session on request
  } = request.session;
  // TODO there's a bug here; if the user has created a game, the game id is not yet parsed from the url parameters
  socket.join(`user-${user.id}`);
  socket.join(`chat-${roomId}`);
  socket.join(`game-${roomId}`);
  socket.use((_, next) => {
    // @ts-expect-error TODO figure out the typing for session on request
    request.session.reload((error) => {
      if (error) {
        socket.disconnect();
      } else {
        next();
      }
    });
  });
};
export default function (
  server: Server,
  app: Express,
  sessionMiddleware: RequestHandler,
): SocketIoServer {
  if (io === undefined) {
    io = new SocketIoServer(server);
    app.set("io", io);
    io.engine.use(sessionMiddleware);
    io.on("connection", async (socket) => {
      await bindSession(socket);
      // @ts-expect-error TODO figure out the typing for session on request
      console.log(`client connected (${socket.request.session.id})`);
      socket.on("disconnect", () => {
        // @ts-expect-error TODO figure out the typing for session on request
        console.log(`client disconnected (${socket.request.session.id})`);
      });
    });
  }
  return io;
}
```

## File: constants/gameConfig.ts
```typescript
import { Card } from '../models/game';
export const BOARD_SIZE = 10;
export const SEQUENCE_LENGTH = 5;
export const MAX_PLAYERS = 4;
export const MIN_PLAYERS = 2;
export const CARDS_PER_PLAYER = 7;
// Define the board layout with card positions
export const BOARD_LAYOUT: Array<Array<Card | null>> = [
  // First row (0)
  [
    { suit: 'hearts', value: '2' },
    { suit: 'hearts', value: '3' },
    { suit: 'hearts', value: '4' },
    { suit: 'hearts', value: '5' },
    { suit: 'hearts', value: '6' },
    { suit: 'hearts', value: '7' },
    { suit: 'hearts', value: '8' },
    { suit: 'hearts', value: '9' },
    { suit: 'hearts', value: '10' },
    { suit: 'hearts', value: 'J' }
  ],
  // Second row (1)
  [
    { suit: 'diamonds', value: '6' },
    { suit: 'diamonds', value: '5' },
    { suit: 'diamonds', value: '4' },
    { suit: 'diamonds', value: '3' },
    { suit: 'diamonds', value: '2' },
    { suit: 'hearts', value: 'Q' },
    { suit: 'hearts', value: 'K' },
    { suit: 'hearts', value: 'A' },
    { suit: 'clubs', value: '2' },
    { suit: 'clubs', value: '3' }
  ],
  // Third row (2)
  [
    { suit: 'diamonds', value: '7' },
    { suit: 'spades', value: 'A' },
    { suit: 'spades', value: 'K' },
    { suit: 'spades', value: 'Q' },
    { suit: 'spades', value: 'J' },
    { suit: 'spades', value: '10' },
    { suit: 'spades', value: '9' },
    { suit: 'clubs', value: 'A' },
    { suit: 'clubs', value: '4' },
    { suit: 'clubs', value: '5' }
  ],
  // Fourth row (3)
  [
    { suit: 'diamonds', value: '8' },
    { suit: 'spades', value: '2' },
    { suit: 'diamonds', value: 'K' },
    { suit: 'diamonds', value: 'Q' },
    { suit: 'diamonds', value: 'J' },
    { suit: 'diamonds', value: '10' },
    { suit: 'spades', value: '8' },
    { suit: 'clubs', value: 'K' },
    { suit: 'clubs', value: '6' },
    { suit: 'clubs', value: '7' }
  ],
  // Fifth row (4)
  [
    { suit: 'diamonds', value: '9' },
    { suit: 'spades', value: '3' },
    { suit: 'diamonds', value: 'A' },
    null, // Corner
    { suit: 'hearts', value: 'A' },
    { suit: 'spades', value: 'A' },
    { suit: 'spades', value: '7' },
    { suit: 'clubs', value: 'Q' },
    { suit: 'clubs', value: '8' },
    { suit: 'clubs', value: '9' }
  ],
  // Sixth row (5)
  [
    { suit: 'diamonds', value: '10' },
    { suit: 'spades', value: '4' },
    { suit: 'hearts', value: 'K' },
    { suit: 'hearts', value: 'Q' },
    null, // Corner
    null, // Corner
    { suit: 'spades', value: '6' },
    { suit: 'clubs', value: 'J' },
    { suit: 'clubs', value: '9' },
    { suit: 'clubs', value: '10' }
  ],
  // Seventh row (6)
  [
    { suit: 'diamonds', value: 'J' },
    { suit: 'spades', value: '5' },
    { suit: 'hearts', value: 'J' },
    { suit: 'hearts', value: '10' },
    { suit: 'hearts', value: '9' },
    { suit: 'spades', value: 'A' },
    { suit: 'spades', value: '5' },
    { suit: 'clubs', value: '10' },
    { suit: 'clubs', value: 'J' },
    { suit: 'clubs', value: 'Q' }
  ],
  // Eighth row (7)
  [
    { suit: 'diamonds', value: 'Q' },
    { suit: 'spades', value: '6' },
    { suit: 'hearts', value: '8' },
    { suit: 'hearts', value: '7' },
    { suit: 'hearts', value: '6' },
    { suit: 'hearts', value: '5' },
    { suit: 'spades', value: '4' },
    { suit: 'clubs', value: '9' },
    { suit: 'clubs', value: 'K' },
    { suit: 'clubs', value: 'K' }
  ],
  // Ninth row (8)
  [
    { suit: 'diamonds', value: 'K' },
    { suit: 'spades', value: '7' },
    { suit: 'hearts', value: '5' },
    { suit: 'hearts', value: '4' },
    { suit: 'hearts', value: '3' },
    { suit: 'hearts', value: '2' },
    { suit: 'spades', value: '3' },
    { suit: 'clubs', value: '8' },
    { suit: 'clubs', value: 'A' },
    { suit: 'clubs', value: 'A' }
  ],
  // Tenth row (9)
  [
    { suit: 'diamonds', value: 'A' },
    { suit: 'spades', value: '8' },
    { suit: 'spades', value: '9' },
    { suit: 'spades', value: '10' },
    { suit: 'spades', value: 'J' },
    { suit: 'spades', value: 'Q' },
    { suit: 'spades', value: '2' },
    { suit: 'clubs', value: '7' },
    { suit: 'clubs', value: '6' },
    { suit: 'clubs', value: '5' }
  ]
];
// Define corner positions
export const CORNER_POSITIONS = [
  { x: 3, y: 4 },
  { x: 4, y: 4 },
  { x: 4, y: 5 },
  { x: 5, y: 4 }
];
// Define player colors
export const PLAYER_COLORS = ['red', 'blue', 'green', 'yellow'];
// Define card deck configuration
export const DECK_CONFIG = {
  suits: ['hearts', 'diamonds', 'clubs', 'spades'] as const,
  values: ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] as const,
  // Each value appears twice in the deck except for Jacks
  duplicatevalues: true,
  // Number of decks to use
  deckCount: 2
};
```

## File: db/games/index.ts
```typescript
import db from "../connection";
import {
  ADD_PLAYER,
  ALL_PLAYER_DATA,
  AVAILABLE_CARDS_FOR_GAME,
  AVAILABLE_GAMES,
  CREATE_GAME,
  DEAL_CARDS,
  GET_PLAYER_HAND,
  GET_PLAYER_COUNT,
  INSERT_INITIAL_CARDS,
  IS_CURRENT,
  SHUFFLE_DISCARD_PILE,
  UPDATE_DRAW_TURN,
  GET_LAST_DRAW_TURN,
  UPDATE_PLAYER_DRAW_TURN,
} from "./sql";
type GameDescription = {
  id: number;
  players: number;
  player_count: number;
};
const create = async (playerId: number): Promise<GameDescription> => {
  const { id } = await db.one<GameDescription>(CREATE_GAME);
  await db.any(INSERT_INITIAL_CARDS, id);
  return await join(id, playerId);
};
const join = async (gameId: number, playerId: number) => {
  const gameDescription = await db.one<GameDescription>(ADD_PLAYER, [
    gameId,
    playerId,
  ]);
  // Pile 0 is the player's hand
  await db.any(DEAL_CARDS, [playerId, 0, gameId, 7]);
  // Pile -1 is the player's play pile
  await db.any(DEAL_CARDS, [playerId, -1, gameId, 20]);
  return gameDescription;
};
const availableGames = async (
  limit: number = 20,
  offset: number = 0,
): Promise<
  {
    id: number;
    players: number;
    currentPlayerIsMember?: boolean;
  }[]
> => {
  return db.any(AVAILABLE_GAMES, [limit, offset]);
};
const getPlayerCount = async (gameId: number): Promise<number> => {
  return parseInt(
    (await db.one<{ count: string }>(GET_PLAYER_COUNT, gameId)).count,
    10,
  );
};
const drawCard = async (gameId: number, userId: number) => {
  const availableCards = parseInt(
    (await db.one<{ count: string }>(AVAILABLE_CARDS_FOR_GAME, gameId)).count,
  );
  if (availableCards === 0) {
    await db.none(SHUFFLE_DISCARD_PILE, [gameId]);
  }
  const card = db.one<{ card_id: string }>(DEAL_CARDS, [userId, 0, gameId, 1]);
  await db.none(UPDATE_DRAW_TURN, [gameId, userId]);
  return card;
};
const incrementTurn = async (gameId: number) => {
  return db.none("UPDATE games SET turn = turn + 1 WHERE id = $1", gameId);
};
const getTurn = async (gameId: number) => {
  return db.one("SELECT turn FROM games WHERE id = $1", gameId);
};
// user_id: -1 for top of discard pile, -2 for bottom of discard pile
// N: -3, E: -4, S: -5, W: -6
const playCard = async () =>
  // playerId: number,
  // gameId: number,
  // cardId: string,
  // pile: number
  {};
const playerGames = async (
  playerId: number,
): Promise<Record<number, boolean>> => {
  return (
    await db.any("SELECT game_id FROM game_users WHERE user_id=$1", playerId)
  ).reduce((memo, game) => ({ ...memo, [game.game_id]: true }), {});
};
const get = async (gameId: number, playerId: number) => {
  const currentSeat = await db.one(
    "SELECT current_seat FROM games WHERE id=$1",
    gameId,
  );
  const players = await getPlayers(gameId);
  const playerHand = await db.any(GET_PLAYER_HAND, [playerId, gameId, 0, 8]);
  return {
    currentSeat,
    players,
    playerHand,
  };
};
const isCurrentPlayer = async (
  gameId: number,
  userId: number,
): Promise<{ is_current_player: boolean }> => {
  return await db.one(IS_CURRENT, [gameId, userId]);
};
const getPlayers = async (
  gameId: number,
): Promise<
  {
    gravatar: string;
    id: number;
    is_current: boolean;
    last_draw_turn: number;
    pile_1: number[];
    pile_2: number[];
    pile_3: number[];
    pile_4: number[];
    play_pile_top: number;
    play_pile_top_id: number;
    play_pile_count: number;
    seat: number;
    username: string;
  }[]
> => {
  return await db.any(ALL_PLAYER_DATA, [gameId]);
};
const getPlayerHand = async (gameId: number, playerId: number) => {
  return await db.any(GET_PLAYER_HAND, [playerId, gameId, 0]);
};
const getLastDrawTurn = async (
  gameId: number,
  userId: number,
): Promise<{ last_draw_turn: number }> => {
  return await db.one(GET_LAST_DRAW_TURN, [gameId, userId]);
};
const updatePlayerDrawTurn = async (gameId: number, userId: number) => {
  return db.none(UPDATE_PLAYER_DRAW_TURN, [gameId, userId]);
};
export default {
  create,
  join,
  availableGames,
  getPlayerCount,
  drawCard,
  playCard,
  playerGames,
  get,
  isCurrentPlayer,
  incrementTurn,
  getTurn,
  getPlayers,
  getPlayerHand,
  getLastDrawTurn,
  updatePlayerDrawTurn,
};
```

## File: db/games/sql.ts
```typescript
export const CREATE_GAME = `
INSERT INTO games DEFAULT VALUES RETURNING *, 1 as players
`;
export const ADD_PLAYER = `
INSERT INTO game_users (game_id, user_id, seat)
VALUES ($1, $2, (SELECT COUNT(*) FROM game_users WHERE game_id = $1) + 1)
RETURNING 
  game_id AS id, 
  (SELECT COUNT(*) FROM game_users WHERE game_id = $1) AS players,
  (SELECT player_count FROM games WHERE id = $1) AS player_count
`;
export const AVAILABLE_GAMES = `
SELECT *, 
  (SELECT COUNT(*) FROM game_users WHERE games.id=game_users.game_id) AS players 
FROM games WHERE id IN 
  (SELECT game_id FROM game_users GROUP BY game_id HAVING COUNT(*) < 4)
LIMIT $1
OFFSET $2
`;
export const GET_PLAYER_COUNT = `
  SELECT COUNT(*) FROM game_users WHERE game_id = $1
`;
export const INSERT_INITIAL_CARDS = `
INSERT INTO game_cards (game_id, card_id, user_id, position, pile)
SELECT $1, id, 0, uuid_generate_v4(), -1 FROM cards
`;
export const DEAL_CARDS = `
UPDATE game_cards 
SET user_id = $1, pile = $2 WHERE game_id = $3 AND user_id = 0 AND position IN (
  SELECT position FROM game_cards WHERE game_id = $3 AND user_id = 0 ORDER BY position LIMIT $4
) RETURNING card_id`;
export const AVAILABLE_CARDS_FOR_GAME = `
SELECT COUNT(*) FROM game_cards WHERE game_id = $1 AND user_id = 0
`;
export const SHUFFLE_DISCARD_PILE = `
UPDATE game_cards SET user_id = 0, position = uuid_generate_v4() WHERE user_id = -2 AND game_id = $1
`;
export const UPDATE_DRAW_TURN = `
UPDATE game_users 
SET last_draw_turn = (SELECT turn FROM games WHERE id = $1) 
WHERE game_id = $1 AND user_id = $2`;
export const THING = `
SELECT COUNT(*) = 1 AS isCurrentPlayer
FROM game_users, games 
WHERE games.id = $1 
  AND game_users.user_id = $2 
  AND games.current_seat = game_users.seat`;
/**
 * Player data that is viewable by all players
 */
const playPileTopSubquery = (field: string) => `
SELECT ${field} 
FROM game_cards, cards 
WHERE game_cards.user_id=users.id 
  AND game_cards.game_id=$1 
  AND game_cards.card_id=cards.id 
  AND pile=-1 
ORDER BY position DESC LIMIT 1
`;
const PLAY_PILE_COUNT = `
SELECT COUNT(*)
FROM game_cards
WHERE game_id = $1 
  AND pile=-1
  AND users.id = game_cards.user_id`;
const discardPileSubquery = (pile: number) => `
  SELECT cards.value FROM game_cards, cards
  WHERE game_cards.user_id=users.id 
    AND game_cards.game_id=$1 
    AND game_cards.card_id=cards.id 
    AND pile=${pile}
  ORDER BY position DESC`;
export const IS_CURRENT = `
  SELECT games.current_seat = game_users.seat AS is_current_player
    FROM games, game_users
    WHERE games.id = $1
    AND game_users.user_id = $2
    AND game_users.game_id = games.id`;
export const ALL_PLAYER_DATA = `
SELECT 
  users.id, 
  users.username, 
  users.gravatar, 
  game_users.seat, 
  game_users.last_draw_turn,
  (
    SELECT games.current_seat = game_users.seat 
    FROM games, game_users
    WHERE games.id = $1
    AND game_users.user_id = users.id
    AND game_users.game_id = games.id
  ) AS is_current,
  (${playPileTopSubquery("cards.value")}) AS play_pile_top,
  (${playPileTopSubquery("cards.id")}) AS play_pile_top_id,
  (${PLAY_PILE_COUNT})::INTEGER AS play_pile_count,
  array(${discardPileSubquery(1)}) AS pile_1,
  array(${discardPileSubquery(2)}) AS pile_2,
  array(${discardPileSubquery(3)}) AS pile_3,
  array(${discardPileSubquery(4)}) AS pile_4
FROM users, game_users
WHERE users.id = game_users.user_id AND game_users.game_id = $1
`;
// Cards in hand
export const GET_PLAYER_HAND = `
SELECT * FROM game_cards, cards 
WHERE game_cards.user_id=$1 
  AND game_cards.game_id=$2 
  AND game_cards.card_id=cards.id 
  AND pile=$3
ORDER BY position DESC
`;
export const PLAYER_DATA = `
${ALL_PLAYER_DATA} AND users.id = $2
`;
export const GET_LAST_DRAW_TURN = `
SELECT last_draw_turn 
FROM game_users 
WHERE game_id=$1 
  AND user_id=$2`;
export const UPDATE_PLAYER_DRAW_TURN = `
UPDATE game_users 
SET last_draw_turn = (SELECT turn FROM games WHERE id=$1) 
WHERE game_id=$1 
  AND user_id=$2`;
```

## File: db/migrations/001_create_users.sql
```sql
-- Create users table
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
-- Create index on email for faster lookups
CREATE INDEX IF NOT EXISTS users_email_idx ON users(email);
-- Create index on username for faster lookups
CREATE INDEX IF NOT EXISTS users_username_idx ON users(username);
-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';
-- Trigger to automatically update updated_at
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## File: db/users/index.ts
```typescript
import bcrypt from "bcrypt";
import { createHash } from "crypto";
import db from "../connection";
import { FIND_BY_EMAIL_SQL, REGISTER_SQL } from "./sql";
type User = {
  id: number;
  username: string;
  email: string;
  gravatar: string;
};
type UserWithPassword = User & {
  password: string;
};
const register = async (
  username: string,
  email: string,
  clearTextPassword: string,
): Promise<User> => {
  const password = await bcrypt.hash(clearTextPassword, 10);
  const gravatar = createHash("sha256").update(email).digest("hex");
  return await db.one(REGISTER_SQL, [username, email, password, gravatar]);
};
const login = async (email: string, clearTextPassword: string) => {
  const user = await findByEmail(email);
  const isValid = await bcrypt.compare(clearTextPassword, user.password);
  if (isValid) {
    return user;
  } else {
    throw new Error("Invalid credentials provided");
  }
};
const findByEmail = (email: string): Promise<UserWithPassword> => {
  return db.one(FIND_BY_EMAIL_SQL, [email]);
};
export default { register, login, findByEmail };
```

## File: db/users/sql.ts
```typescript
export const REGISTER_SQL = `
  INSERT INTO users (username, email, password, gravatar)
  VALUES ($1, $2, $3, $4)
  RETURNING id, username, email, gravatar
`;
export const FIND_BY_EMAIL_SQL = `
  SELECT * FROM users WHERE email = $1
`;
```

## File: db/connection.ts
```typescript
import pgp from "pg-promise";
const connection = pgp()(process.env.DATABASE_URL!);
export default connection;
```

## File: db/index.ts
```typescript
export { default as Users } from "./users";
export { default as Games } from "./games";
```

## File: db/migrate.ts
```typescript
import { db } from '../config/database';
import * as fs from 'fs';
import * as path from 'path';
async function runMigrations() {
  try {
    // Create migrations table if it doesn't exist
    await db.none(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        executed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Get all migration files
    const migrationsDir = path.join(__dirname, 'migrations');
    const migrationFiles = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort();
    // Get executed migrations
    const executedMigrations = await db.map(
      'SELECT name FROM migrations',
      [],
      row => row.name
    );
    // Run pending migrations
    for (const file of migrationFiles) {
      if (!executedMigrations.includes(file)) {
        console.log(`Running migration: ${file}`);
        const sql = fs.readFileSync(path.join(migrationsDir, file), 'utf8');
        await db.tx(async t => {
          await t.none(sql);
          await t.none('INSERT INTO migrations(name) VALUES($1)', [file]);
        });
        console.log(`Completed migration: ${file}`);
      }
    }
    console.log('All migrations completed successfully');
    process.exit(0);
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}
runMigrations();
```

## File: middleware/auth.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { UserModel } from '../models/user';
// Extend Express Request type to include user
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        username: string;
        email: string;
        // Add any other properties needed
      };
    }
  }
}
/**
 * Authentication middleware to protect routes
 */
export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }
    const [bearer, token] = authHeader.split(' ');
    if (bearer !== 'Bearer' || !token) {
      res.status(401).json({ error: 'Invalid token format' });
      return;
    }
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
      const user = await UserModel.findById(decoded.userId);
      if (!user) {
        res.status(401).json({ error: 'User not found' });
        return;
      }
      // Add user to request object without password hash
      const { password_hash, ...userWithoutPassword } = user;
      req.user = userWithoutPassword;
      next();
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        res.status(401).json({ error: 'Token expired' });
      } else {
        res.status(401).json({ error: 'Invalid token' });
      }
    }
  } catch (error) {
    next(error);
  }
};
/**
 * Optional authentication middleware that doesn't require authentication
 * but will add user to request if token is valid
 */
export const optionalAuthenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      next();
      return;
    }
    const [bearer, token] = authHeader.split(' ');
    if (bearer !== 'Bearer' || !token) {
      next();
      return;
    }
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
      const user = await UserModel.findById(decoded.userId);
      if (user) {
        // Add user to request object without password hash
        const { password_hash, ...userWithoutPassword } = user;
        req.user = userWithoutPassword;
      }
    } catch (error) {
      // Ignore token validation errors in optional authentication
    }
    next();
  } catch (error) {
    next(error);
  }
};
/**
 * Middleware to validate refresh tokens
 */
export const validateRefreshToken = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { refreshToken } = req.body;
    if (!refreshToken) {
      res.status(400).json({ error: 'Refresh token required' });
      return;
    }
    const result = await UserModel.refreshToken(refreshToken);
    if (!result) {
      res.status(401).json({ error: 'Invalid refresh token' });
      return;
    }
    res.json(result);
  } catch (error) {
    next(error);
  }
};
export const verifyToken = async (token: string): Promise<{ id: string; username: string; email: string; } | null> => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
    const user = await UserModel.findById(decoded.userId);
    if (!user) {
      return null;
    }
    const { password_hash, ...userWithoutPassword } = user;
    return userWithoutPassword;
  } catch (error) {
    return null;
  }
};
```

## File: middleware/authentication.ts
```typescript
import { NextFunction, Request, Response } from "express";
const authenticationMiddleware = (
  request: Request,
  response: Response,
  next: NextFunction,
) => {
  if (!request.session.user) {
    response.redirect("/auth/login");
  } else {
    response.locals.user = request.session.user;
    next();
  }
};
export default authenticationMiddleware;
```

## File: middleware/chat.ts
```typescript
import { NextFunction, Request, Response } from "express";
const chatMiddleware = (
  request: Request,
  response: Response,
  next: NextFunction,
) => {
  const gameIdMatch = request.headers.referer?.match(/\/games\/(\d+)/);
  const gameId = parseInt(gameIdMatch ? gameIdMatch[1] : "0");
  // @ts-expect-error TODO figure out the typing for session on request
  request.session.roomId = gameId;
  if (gameId !== undefined) {
    response.locals.roomId = gameId;
  } else {
    response.locals.roomId = 0;
  }
  next();
};
export default chatMiddleware;
```

## File: middleware/error.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import expressValidator from 'express-validator';
import { JsonWebTokenError } from 'jsonwebtoken';
interface ErrorWithStatus extends Error {
  status?: number;
  statusCode?: number;
  errors?: expressValidator.ValidationError[];
}
/**
 * Custom error handler middleware
 */
export const errorHandler = (
  err: ErrorWithStatus,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  console.error(err);
  // Handle validation errors
  if (err.errors && Array.isArray(err.errors)) {
    res.status(400).json({
      error: 'Validation Error',
      details: err.errors.map(error => ({
        field: error.type,
        message: error.msg 
      }))
    });
    return;
  }
  // Handle JWT errors
  if (err instanceof JsonWebTokenError) {
    res.status(401).json({
      error: 'Authentication Error',
      message: 'Invalid or expired token'
    });
    return;
  }
  // Handle known errors with status codes
  const statusCode = err.status || err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  res.status(statusCode).json({
    error: statusCode === 500 ? 'Internal Server Error' : message,
    message: statusCode === 500 ? 'An unexpected error occurred' : message
  });
};
/**
 * Not found error handler
 */
export const notFoundHandler = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  next(createError(404, 'Resource not found'));
};
/**
 * Async error wrapper to handle promise rejections
 */
export const asyncHandler = (fn: Function) => (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  Promise.resolve(fn(req, res, next)).catch(next);
}; 
function createError(status: number, message: string): ErrorWithStatus {
  const error: ErrorWithStatus = new Error(message);
  error.status = status;
  return error;
}
```

## File: middleware/index.ts
```typescript
export { default as authentication } from "./authentication";
export { default as chat } from "./chat";
export { default as tailwind } from "./tailwind-util";
```

## File: middleware/tailwind-util.ts
```typescript
import { NextFunction, Request, Response } from "express";
import clsx from "clsx";
import { twMerge } from "tailwind-merge";
const cn = (...args: string[]) => twMerge(clsx(...args));
const tailwindMiddleware = (
  _request: Request,
  response: Response,
  next: NextFunction,
) => {
  response.locals.cn = cn;
  next();
};
export default tailwindMiddleware;
```

## File: models/game.ts
```typescript
import { db } from '../config/database';
import {
  BOARD_LAYOUT,
  BOARD_SIZE,
  SEQUENCE_LENGTH,
  MAX_PLAYERS,
  MIN_PLAYERS,
  CARDS_PER_PLAYER,
  CORNER_POSITIONS,
  DECK_CONFIG
} from '../constants/gameConfig';
export interface Card {
  suit: string;
  value: string;
}
export interface Position {
  x: number;
  y: number;
}
export interface GameState {
  board: Array<Array<Card | null>>;
  chips: Array<Array<string | null>>; // Player color or null
  currentPlayerIndex: number;
  players: Array<{
    id: string;
    username: string;
    cards: Card[];
    chips: Position[];
    color: string;
  }>;
  deck: Card[];
  status: 'waiting' | 'in_progress' | 'completed' | 'cancelled';
  winner?: string;
}
export interface GameMove {
  id: string;
  gameId: string;
  userId: string;
  cardPlayed: Card;
  position: Position;
  createdAt: Date;
}
export class GameModel {
  /**
   * Create a new game
   */
  static async create(creatorId: string): Promise<{ id: string; state: GameState }> {
    const initialState: GameState = {
      board: BOARD_LAYOUT,
      chips: Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)),
      currentPlayerIndex: 0,
      players: [{
        id: creatorId,
        username: '', // Will be populated after creation
        cards: [],
        chips: [],
        color: 'red'
      }],
      deck: this.createDeck(),
      status: 'waiting'
    };
    const game = await db.one<{ id: string; board_state: GameState }>(
      `
      INSERT INTO games (board_state, status)
      VALUES ($1, $2)
      RETURNING id, board_state
      `,
      [initialState, 'waiting']
    );
    // Add creator as first player
    await db.none(
      `
      INSERT INTO game_players (game_id, user_id, player_index, cards)
      VALUES ($1, $2, $3, $4)
      `,
      [game.id, creatorId, 0, []]
    );
    return { id: game.id, state: game.board_state };
  }
  /**
   * Join a game
   */
  static async join(gameId: string, userId: string): Promise<GameState> {
    const game = await db.one<{ board_state: GameState }>(
      `
      SELECT board_state
      FROM games
      WHERE id = $1 AND status = 'waiting'
      `,
      [gameId]
    );
    if (game.board_state.players.length >= MAX_PLAYERS) {
      throw new Error('Game is full');
    }
    if (game.board_state.players.some(p => p.id === userId)) {
      throw new Error('Player already in game');
    }
    const playerIndex = game.board_state.players.length;
    const playerColor = ['red', 'blue', 'green', 'yellow'][playerIndex];
    game.board_state.players.push({
      id: userId,
      username: '', // Will be populated after join
      cards: [],
      chips: [],
      color: playerColor
    });
    // Add player to game
    await db.none(
      `
      INSERT INTO game_players (game_id, user_id, player_index, cards)
      VALUES ($1, $2, $3, $4)
      `,
      [gameId, userId, playerIndex, []]
    );
    // Update game state
    await db.none(
      `
      UPDATE games
      SET board_state = $1
      WHERE id = $2
      `,
      [game.board_state, gameId]
    );
    return game.board_state;
  }
  /**
   * Start a game
   */
  static async start(gameId: string): Promise<GameState> {
    const game = await db.one<{ board_state: GameState }>(
      `
      SELECT board_state
      FROM games
      WHERE id = $1 AND status = 'waiting'
      `,
      [gameId]
    );
    if (game.board_state.players.length < MIN_PLAYERS) {
      throw new Error('Not enough players');
    }
    // Deal cards to players
    const deck = this.shuffleDeck(game.board_state.deck);
    game.board_state.players.forEach((player) => {
      player.cards = deck.splice(0, CARDS_PER_PLAYER);
    });
    game.board_state.deck = deck;
    game.board_state.status = 'in_progress';
    // Update game state and status
    await db.none(
      `
      UPDATE games
      SET board_state = $1, status = 'in_progress'
      WHERE id = $2
      `,
      [game.board_state, gameId]
    );
    // Update player cards
    for (const player of game.board_state.players) {
      await db.none(
        `
        UPDATE game_players
        SET cards = $1
        WHERE game_id = $2 AND user_id = $3
        `,
        [player.cards, gameId, player.id]
      );
    }
    return game.board_state;
  }
  /**
   * Make a move in the game
   */
  static async makeMove(
    gameId: string,
    userId: string,
    card: Card,
    position: Position
  ): Promise<GameState> {
    const game = await db.one<{ board_state: GameState }>(
      `
      SELECT board_state
      FROM games
      WHERE id = $1 AND status = 'in_progress'
      `,
      [gameId]
    );
    const playerIndex = game.board_state.players.findIndex(p => p.id === userId);
    if (playerIndex === -1) {
      throw new Error('Player not in game');
    }
    if (playerIndex !== game.board_state.currentPlayerIndex) {
      throw new Error('Not your turn');
    }
    if (!this.isValidMove(game.board_state, card, position)) {
      throw new Error('Invalid move');
    }
    // Record the move
    await db.none(
      `
      INSERT INTO game_moves (game_id, user_id, card_played, position)
      VALUES ($1, $2, $3, $4)
      `,
      [gameId, userId, card, position]
    );
    // Update game state
    const player = game.board_state.players[playerIndex];
    // Remove card from player's hand
    player.cards = player.cards.filter(c => 
      !(c.suit === card.suit && c.value === card.value)
    );
    // Add chip to board
    game.board_state.chips[position.y][position.x] = player.color;
    player.chips.push(position);
    // Draw a new card if deck is not empty
    if (game.board_state.deck.length > 0) {
      player.cards.push(game.board_state.deck.pop()!);
    }
    // Check for win condition
    if (this.checkWinCondition(game.board_state.chips, player.color)) {
      game.board_state.status = 'completed';
      game.board_state.winner = userId;
    } else {
      // Move to next player
      game.board_state.currentPlayerIndex = 
        (game.board_state.currentPlayerIndex + 1) % game.board_state.players.length;
    }
    // Update game state in database
    await db.none(
      `
      UPDATE games
      SET board_state = $1, status = $2, winner_id = $3
      WHERE id = $4
      `,
      [
        game.board_state,
        game.board_state.status,
        game.board_state.winner || null,
        gameId
      ]
    );
    // Update player cards
    await db.none(
      `
      UPDATE game_players
      SET cards = $1
      WHERE game_id = $2 AND user_id = $3
      `,
      [player.cards, gameId, userId]
    );
    return game.board_state;
  }
  /**
   * Get current game state
   */
  static async getState(gameId: string): Promise<GameState> {
    const game = await db.one<{ board_state: GameState }>(
      `
      SELECT board_state
      FROM games
      WHERE id = $1
      `,
      [gameId]
    );
    return game.board_state;
  }
  /**
   * List available games
   */
  static async listGames(): Promise<Array<{
    id: string;
    playerCount: number;
    status: string;
    createdAt: Date;
  }>> {
    const result = await db.query(`
      SELECT g.id, 
             COUNT(gp.id) as player_count, 
             g.status, 
             g.created_at
      FROM games g
      LEFT JOIN game_players gp ON g.id = gp.game_id
      WHERE g.status = 'waiting'
      GROUP BY g.id
      ORDER BY g.created_at DESC
    `);
    return result.rows.map((row: { id: any; player_count: string; status: any; created_at: any; }) => ({
      id: row.id,
      playerCount: parseInt(row.player_count),
      status: row.status,
      createdAt: row.created_at
    }));
  }
  // Helper methods
  private static createDeck(): Card[] {
    const deck: Card[] = [];
    const { suits, values, duplicatevalues, deckCount } = DECK_CONFIG;
    for (let deckIndex = 0; deckIndex < deckCount; deckIndex++) {
      for (const suit of suits) {
        for (const value of values) {
          // Add each card twice (except Jacks)
          const card = { suit, value };
          deck.push(card);
          if (duplicatevalues && value !== 'J') {
            deck.push({ ...card });
          }
        }
      }
    }
    return this.shuffleDeck(deck);
  }
  private static shuffleDeck(deck: Card[]): Card[] {
    const shuffled = [...deck];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  private static isValidMove(state: GameState, card: Card, position: Position): boolean {
    const { x, y } = position;
    // Check if position is within bounds
    if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) {
      return false;
    }
    // Check if position is already taken
    if (state.chips[y][x] !== null) {
      return false;
    }
    // Check if it's a corner (free space)
    if (CORNER_POSITIONS.some(pos => pos.x === x && pos.y === y)) {
      return true;
    }
    // Get the card at the board position
    const boardCard = state.board[y][x];
    if (!boardCard) {
      return false;
    }
    // Check if player has the card
    const player = state.players[state.currentPlayerIndex];
    const hasCard = player.cards.some(c => 
      c.suit === card.suit && c.value === card.value
    );
    if (!hasCard) {
      return false;
    }
    // Handle Jacks
    if (card.value === 'J') {
      if (card.suit === 'hearts' || card.suit === 'diamonds') {
        // One-eyed Jack (remove any chip)
        return state.chips[y][x] !== null;
      } else {
        // Two-eyed Jack (place chip anywhere)
        return state.chips[y][x] === null;
      }
    }
    // Normal card - must match the board position
    return boardCard.suit === card.suit && boardCard.value === card.value;
  }
  private static checkWinCondition(chips: Array<Array<string | null>>, playerColor: string): boolean {
    // Check horizontal sequences
    for (let y = 0; y < BOARD_SIZE; y++) {
      for (let x = 0; x <= BOARD_SIZE - SEQUENCE_LENGTH; x++) {
        if (this.checkSequence(chips, x, y, 1, 0, playerColor)) {
          return true;
        }
      }
    }
    // Check vertical sequences
    for (let y = 0; y <= BOARD_SIZE - SEQUENCE_LENGTH; y++) {
      for (let x = 0; x < BOARD_SIZE; x++) {
        if (this.checkSequence(chips, x, y, 0, 1, playerColor)) {
          return true;
        }
      }
    }
    // Check diagonal sequences (top-left to bottom-right)
    for (let y = 0; y <= BOARD_SIZE - SEQUENCE_LENGTH; y++) {
      for (let x = 0; x <= BOARD_SIZE - SEQUENCE_LENGTH; x++) {
        if (this.checkSequence(chips, x, y, 1, 1, playerColor)) {
          return true;
        }
      }
    }
    // Check diagonal sequences (top-right to bottom-left)
    for (let y = 0; y <= BOARD_SIZE - SEQUENCE_LENGTH; y++) {
      for (let x = SEQUENCE_LENGTH - 1; x < BOARD_SIZE; x++) {
        if (this.checkSequence(chips, x, y, -1, 1, playerColor)) {
          return true;
        }
      }
    }
    return false;
  }
  private static checkSequence(
    chips: Array<Array<string | null>>,
    startX: number,
    startY: number,
    dx: number,
    dy: number,
    playerColor: string
  ): boolean {
    for (let i = 0; i < SEQUENCE_LENGTH; i++) {
      const x = startX + i * dx;
      const y = startY + i * dy;
      if (chips[y][x] !== playerColor) {
        return false;
      }
    }
    return true;
  }
}
```

## File: models/user.ts
```typescript
import bcrypt from 'bcrypt';
import { db } from '../config/database';
import jwt from 'jsonwebtoken';
import session from 'express-session';
declare module 'express-session' {
  export interface SessionData {
    user: { [key: string]: any };
  }
}
export interface User {
  id: string;
  username: string;
  email: string;
  password_hash: string;
  created_at: Date;
  updated_at: Date;
}
export interface UserCreateInput {
  username: string;
  email: string;
  password: string;
}
export interface UserLoginInput {
  email: string;
  password: string;
}
export class UserModel {
  private static readonly SALT_ROUNDS = 10;
  /**
   * Create a new user
   */
  static async create({ username, email, password }: UserCreateInput): Promise<User> {
    const password_hash = await bcrypt.hash(password, this.SALT_ROUNDS);
    return db.one<User>(
      `
      INSERT INTO users (username, email, password_hash)
      VALUES ($1, $2, $3)
      RETURNING *
      `,
      [username, email, password_hash]
    );
  }
  /**
   * Find a user by their ID
   */
  static async findById(id: string): Promise<User | null> {
    return db.oneOrNone<User>('SELECT * FROM users WHERE id = $1', [id]);
  }
  /**
   * Find a user by their username
   */
  static async findByUsername(username: string): Promise<User | null> {
    return db.oneOrNone<User>('SELECT * FROM users WHERE username = $1', [username]);
  }
  /**
   * Find a user by their email
   */
  static async findByEmail(email: string): Promise<User | null> {
    return db.oneOrNone<User>('SELECT * FROM users WHERE email = $1', [email]);
  }
  /**
   * Authenticate a user and return JWT tokens if successful
   */
  static async authenticate({ email, password }: UserLoginInput): Promise<{ 
    user: Omit<User, 'password_hash'>,
    token: string,
    refreshToken: string 
  } | null> {
    const user = await this.findByEmail(email);
    if (!user) {
      return null;
    }
    const isValid = await bcrypt.compare(password, user.password_hash);
    if (!isValid) {
      return null;
    }
    const token = jwt.sign(
      { userId: user.id },
      process.env.JWT_SECRET!,
      { expiresIn: process.env.JWT_EXPIRY }
    );
    const refreshToken = jwt.sign(
      { userId: user.id, type: 'refresh' },
      process.env.JWT_SECRET!,
      { expiresIn: process.env.JWT_REFRESH_EXPIRY }
    );
    const { password_hash, ...userWithoutPassword } = user;
    return {
      user: userWithoutPassword,
      token,
      refreshToken
    };
  }
  /**
   * Refresh a JWT token
   */
  static async refreshToken(refreshToken: string): Promise<{ token: string } | null> {
    try {
      const decoded = jwt.verify(refreshToken, process.env.JWT_SECRET!) as { userId: string, type: string };
      if (decoded.type !== 'refresh') {
        return null;
      }
      const user = await this.findById(decoded.userId);
      if (!user) {
        return null;
      }
      const token = jwt.sign(
        { userId: user.id },
        process.env.JWT_SECRET!,
        { expiresIn: process.env.JWT_EXPIRY }
      );
      return { token };
    } catch (error) {
      return null;
    }
  }
  /**
   * Update a user's information
   */
  static async update(
    id: string,
    updates: Partial<Omit<UserCreateInput, 'password'> & { password?: string }>
  ): Promise<User> {
    const updateFields: string[] = [];
    const values: any[] = [];
    let valueIndex = 1;
    if (updates.username) {
      updateFields.push(`username = $${valueIndex}`);
      values.push(updates.username);
      valueIndex++;
    }
    if (updates.email) {
      updateFields.push(`email = $${valueIndex}`);
      values.push(updates.email);
      valueIndex++;
    }
    if (updates.password) {
      const password_hash = await bcrypt.hash(updates.password, this.SALT_ROUNDS);
      updateFields.push(`password_hash = $${valueIndex}`);
      values.push(password_hash);
      valueIndex++;
    }
    values.push(id);
    return db.one<User>(
      `
      UPDATE users
      SET ${updateFields.join(', ')}
      WHERE id = $${valueIndex}
      RETURNING *
      `,
      values
    );
  }
}
```

## File: routes/game-middleware/broadcast-game-update.ts
```typescript
import { NextFunction, Request, Response } from "express";
import { Games } from "../../db";
export const broadcastGameUpdate = async (
  request: Request,
  response: Response,
  next: NextFunction,
) => {
  const gameId = parseInt(request.params.gameId, 10);
  const playerData = await Games.getPlayers(gameId);
  const socket = request.app.get("io");
  for (let index = 0; index < playerData.length; index++) {
    const player = playerData[index];
    socket.to(`user-${player.id}`).emit(`game:${gameId}:updated`, {
      players: playerData.filter((p) => p.id !== player.id),
      player: {
        ...playerData.find((p) => p.id === player.id),
        hand: await Games.getPlayerHand(gameId, player.id),
      },
    });
  }
  next();
};
```

## File: routes/game-middleware/can-player-draw.ts
```typescript
import { NextFunction, Request, Response } from "express";
import { Games } from "../../db";
export const canPlayerDraw = async (
  request: Request,
  response: Response,
  next: NextFunction,
) => {
  const gameId = parseInt(request.params.gameId, 10);
  // @ts-expect-error TODO: Define the session type for the user object
  const { id: userId } = request.session.user;
  const { turn: currentGameTurn } = await Games.getTurn(gameId);
  const { last_draw_turn: lastDrawTurn } = await Games.getLastDrawTurn(
    gameId,
    userId,
  );
  const socket = request.app.get("io");
  if (currentGameTurn === lastDrawTurn) {
    response.status(401);
    socket.to(`user-${userId}`).emit(`message:${gameId}`, {
      message: "You have already drawn a card this turn",
      sender: "system",
      gravatar: "123456789?d=robohash",
      timestamp: new Date(),
    });
    return;
  } else {
    next();
  }
};
```

## File: routes/game-middleware/index.ts
```typescript
export { isPlayersTurn } from "./is-players-turn";
export { canPlayerDraw } from "./can-player-draw";
export { broadcastGameUpdate } from "./broadcast-game-update";
```

## File: routes/game-middleware/is-players-turn.ts
```typescript
import { NextFunction, Request, Response } from "express";
import { Games } from "../../db";
export const isPlayersTurn = async (
  request: Request,
  response: Response,
  next: NextFunction,
) => {
  const gameId = parseInt(request.params.gameId, 10);
  if (!gameId) {
    response.sendStatus(400);
    return;
  }
  // @ts-expect-error TODO: Define the session type for the user object
  const { id: userId } = request.session.user;
  const socket = request.app.get("io");
  const { is_current_player: isCurrentPlayer } = await Games.isCurrentPlayer(
    gameId,
    userId,
  );
  if (!isCurrentPlayer) {
    response.sendStatus(401);
    socket.to(`user-${userId}`).emit(`message:${gameId}`, {
      message: "You can not play when it is not your turn",
      sender: "system",
      gravatar: "123456789?d=robohash",
      timestamp: new Date(),
    });
    return;
  } else {
    next();
  }
};
```

## File: routes/auth.ts
```typescript
import express, { Router, Request, Response, NextFunction } from 'express';
import { check, validationResult } from 'express-validator';
import { UserModel } from '../models/user';
import { authenticate } from '../middleware/auth';
const router = Router();
// Validation middleware
const registerValidation = [
  check('username').notEmpty().trim().escape(),
  check('email').isEmail().normalizeEmail(),
  check('password').isLength({ min: 6 })
];
const loginValidation = [
  check('email').isEmail().normalizeEmail(),
  check('password').notEmpty()
];
// GET register page
router.get('/register', (_req: Request, res: Response) => {
  res.render('auth/register', { title: 'Register' });
});
// GET login page
router.get('/login', (_req: Request, res: Response) => {
  res.render('auth/login', { title: 'Login' });
});
// Register route
router.post('/register', registerValidation, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      if (req.headers.accept?.includes('application/json')) {
        res.status(400).json({ errors: errors.array() });
      } else {
        res.render('auth/register', { 
          title: 'Register',
          error: errors.array()[0].msg,
          values: req.body
        });
      }
      return;
    }
    const { username, email, password } = req.body;
    const user = await UserModel.create({ username, email, password });
    const auth = await UserModel.authenticate({ email, password });
    if (!auth) {
      const error = 'Authentication failed after registration';
      if (req.headers.accept?.includes('application/json')) {
        res.status(500).json({ error });
      } else {
        res.render('auth/register', { 
          title: 'Register',
          error,
          values: req.body
        });
      }
      return;
    }
    if (req.headers.accept?.includes('application/json')) {
      res.status(201).json({ token: auth.token, refreshToken: auth.refreshToken });
    } else {
      req.session.user = auth.user;
      res.redirect('/');
    }
  } catch (err) {
    next(err);
  }
});
// Login route
router.post('/login', loginValidation, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      if (req.headers.accept?.includes('application/json')) {
        res.status(400).json({ errors: errors.array() });
      } else {
        res.render('auth/login', { 
          title: 'Login',
          error: errors.array()[0].msg,
          values: req.body
        });
      }
      return;
    }
    const { email, password } = req.body;
    const auth = await UserModel.authenticate({ email, password });
    if (!auth) {
      const error = 'Invalid credentials';
      if (req.headers.accept?.includes('application/json')) {
        res.status(401).json({ error });
      } else {
        res.render('auth/login', { 
          title: 'Login',
          error,
          values: req.body
        });
      }
      return;
    }
    if (req.headers.accept?.includes('application/json')) {
      res.json({ token: auth.token, refreshToken: auth.refreshToken });
    } else {
      console.log('Setting session user:', auth.user);
      req.session.user = auth.user;
      req.session.save((err) => {
        if (err) {
          console.error('Session save error:', err);
          next(err);
          return;
        }
        console.log('Session saved successfully');
        res.redirect('/');
      });
    }
  } catch (err) {
    next(err);
  }
});
// Get current user route
router.get('/me', authenticate, async (req: Request, res: Response) => {
  const user = await UserModel.findById(req.user!.id);
  if (!user) {
    res.status(404).json({ error: 'User not found' });
    return;
  }
  const { password_hash, ...userWithoutPassword } = user;
  res.json(userWithoutPassword);
});
export default router;
```

## File: routes/chat.ts
```typescript
import express from "express";
const router = express.Router();
router.post("/:roomId", (request, response) => {
  const { roomId } = request.params;
  const { message } = request.body;
  // @ts-expect-error TODO: Define the session type for the user object
  const { email, gravatar } = request.session.user;
  request.app.get("io").to(`game-${roomId}`).emit(`message:${roomId}`, {
    message,
    gravatar,
    sender: email,
    timestamp: new Date(),
  });
  response.status(200).send();
});
export default router;
```

## File: routes/games.ts
```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { check, validationResult } from 'express-validator';
import { GameModel } from '../models/game';
import { authenticate } from '../middleware/auth';
const router = Router();
// Validation middleware
const gameValidation = [
  check('position').isObject().withMessage('Position must be an object'),
  check('position.x').isInt({ min: 0, max: 9 }).withMessage('X position must be between 0 and 9'),
  check('position.y').isInt({ min: 0, max: 9 }).withMessage('Y position must be between 0 and 9'),
  check('cardId').isString().notEmpty().withMessage('Card ID is required')
];
// Create a new game
router.post('/', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const game = await GameModel.create(req.user!.id);
    res.status(201).json(game);
  } catch (err) {
    next(err);
  }
});
// Join a game
router.post('/:id/join', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const gameState = await GameModel.join(req.params.id, req.user!.id);
    res.json(gameState);
  } catch (err) {
    next(err);
  }
});
// Start a game
router.post('/:id/start', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const gameState = await GameModel.start(req.params.id);
    res.json(gameState);
  } catch (err) {
    next(err);
  }
});
// Make a move
router.post('/:id/play', authenticate, gameValidation, async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    const { position, cardId } = req.body;
    const gameState = await GameModel.makeMove(req.params.id, req.user!.id, cardId, position);
    res.json(gameState);
  } catch (err) {
    next(err);
  }
});
// Get game state
router.get('/:id', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const gameState = await GameModel.getState(req.params.id);
    res.json(gameState);
  } catch (err) {
    next(err);
  }
});
// List available games
router.get('/', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const games = await GameModel.listGames();
    res.json(games);
  } catch (err) {
    next(err);
  }
});
export default router;
```

## File: routes/home.ts
```typescript
import express from "express";
const router = express.Router();
router.get("/", (request, response) => {
  // If user is authenticated, redirect to main lobby
  if (request.session.user) {
    response.redirect('/lobby');
    return;
  }
  // Otherwise render the home page for guests
  response.render("home", { title: "Welcome" });
});
export default router;
```

## File: routes/index.ts
```typescript
export { default as auth } from "./auth";
export { default as chat } from "./chat";
export { default as games } from "./games";
export { default as home } from "./home";
export { default as mainLobby } from "./main-lobby";
export { default as test } from "./test";
```

## File: routes/main-lobby.ts
```typescript
import express from "express";
import { Games } from "../db";
const router = express.Router();
router.get("/", async (request, response) => {
  const user = request.session.user;
  console.log('Main lobby session user:', user);
  // Handle guest users by redirecting to login
  if (!user) {
    console.log('No user in session, redirecting to login');
    response.redirect('/auth/login');
    return;
  }
  const availableGames = await Games.availableGames();
  const playerGames: Record<number, boolean> = await Games.playerGames(user.id);
  // Add currentPlayerIsMember flag to each game
  availableGames.forEach((game) => {
    game.currentPlayerIsMember = playerGames[game.id] || false;
  });
  console.log('Rendering main lobby for user:', user.username);
  response.render("main-lobby", { 
    title: "Game Lobby",
    user,
    availableGames
  });
});
export default router;
```

## File: routes/test.ts
```typescript
import express from "express";
import db from "../db/connection";
const router = express.Router();
router.get("/db", async (_request, response) => {
  try {
    await db.any(`INSERT INTO test (test_string) VALUES ($1)`, [
      `Hello on ${new Date().toLocaleString()}`,
    ]);
    const results = await db.any(`SELECT * FROM test`);
    response.json(results);
  } catch (error) {
    // @ts-expect-error TODO: Fix this typing so I can use `any` in catch statements
    response.status(500).json({ error: error.message });
  }
});
export default router;
```

## File: socket/gameHandlers.ts
```typescript
import { Server, Socket } from 'socket.io';
import { ExtendedError } from 'socket.io/dist/namespace';
import { GameModel } from '../models/game';
import { verifyToken } from '../middleware/auth';
import {
  GameSocket,
  ServerToClientEvents,
  ClientToServerEvents,
  InterServerEvents,
  SocketData
} from '../types/socket';
export const configureGameHandlers = (
  io: Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>
) => {
  // Authentication middleware
  io.use(async (socket: Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>, next) => {
    try {
      const token = socket.handshake.auth.token;
      if (!token) {
        return next(new Error('Authentication required'));
      }
      const user = await verifyToken(token);
      if (!user) {
        return next(new Error('Invalid token'));
      }
      const gameSocket = socket as GameSocket;
      gameSocket.userId = user.id;
      gameSocket.gameRooms = new Map();
      next();
    } catch (err) {
      next(err instanceof Error ? err : new Error('Authentication failed'));
    }
  });
  // Connection handler
  io.on('connection', (socket: Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>) => {
    const gameSocket = socket as GameSocket;
    console.log(`User ${gameSocket.userId} connected`);
    gameSocket.on('joinGame', async (gameId: string) => {
      try {
        const gameState = await GameModel.getState(gameId);
        // Add socket to game room
        gameSocket.join(gameId);
        gameSocket.gameRooms.set(gameId, {
          id: gameId,
          players: gameState.players.map(p => p.id),
          spectators: [],
          gameState
        });
        // Notify other players
        gameSocket.to(gameId).emit('playerJoined', gameSocket.userId!);
        // Send initial game state
        io.to(gameId).emit('gameUpdate', gameState);
      } catch (err) {
        gameSocket.emit('gameError', err instanceof Error ? err.message : 'Failed to join game');
      }
    });
    gameSocket.on('leaveGame', (gameId: string) => {
      gameSocket.leave(gameId);
      gameSocket.gameRooms.delete(gameId);
      gameSocket.to(gameId).emit('playerLeft', gameSocket.userId!);
    });
    gameSocket.on('playCard', async (gameId: string, cardId: string, position: { x: number; y: number }) => {
      try {
        const [suit, value] = cardId.split('');
        const card = { suit, value };
        const gameState = await GameModel.makeMove(gameId, gameSocket.userId!, card, position);
        io.to(gameId).emit('gameUpdate', gameState);
      } catch (err) {
        gameSocket.emit('gameError', err instanceof Error ? err.message : 'Failed to play card');
      }
    });
    gameSocket.on('disconnect', () => {
      console.log(`User ${gameSocket.userId} disconnected`);
      // Clean up game rooms
      gameSocket.gameRooms.forEach((room, gameId) => {
        gameSocket.to(gameId).emit('playerLeft', gameSocket.userId!);
      });
    });
  });
};
```

## File: types/express-session.d.ts
```typescript
import session from 'express-session';
declare module 'express-session' {
  export interface SessionData {
    user: { [key: string]: any };
  }
}
```

## File: types/socket.ts
```typescript
import { Socket } from 'socket.io';
import { DefaultEventsMap } from 'socket.io/dist/typed-events';
export interface GameRoom {
  id: string;
  players: string[];
  spectators: string[];
  gameState: any; // Replace with your game state type
}
export interface GameSocket extends Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData> {
  gameRooms: Map<string, GameRoom>;
  userId?: string;
}
export interface ServerToClientEvents {
  gameUpdate: (gameState: any) => void;
  playerJoined: (playerId: string) => void;
  playerLeft: (playerId: string) => void;
  gameError: (error: string) => void;
}
export interface ClientToServerEvents {
  joinGame: (gameId: string) => void;
  leaveGame: (gameId: string) => void;
  playCard: (gameId: string, cardId: string, position: { x: number; y: number }) => void;
}
export interface InterServerEvents {
  ping: () => void;
}
export interface SocketData {
  userId: string;
  gameRooms: Map<string, GameRoom>;
}
```

## File: views/auth/login.ejs
```
<% if (messages.error) { %>
  <p class="text-red-500"><%= messages.error %></p>
<% } %>

<form method="post" action="/auth/login" class="container w-[50%] mx-auto">
  <div class="mb-[8px]">
    <label for="email">Email</label>
    <div class="pt-[2px]">
      <input
        type="email"
        id="email"
        name="email"
        placeholder="you@domain.com"
        required
        class="block w-full px-2 rounded-md border-0 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-[2px] focus:ring-inset"
      />
    </div>
  </div>  
  <div class="mb-[8px]">
    <label for="password">Password</label>
    <div class="pt-[2px]">
      <input 
        type="password" 
        id="password" 
        name="password" 
        required 
        class="block w-full px-2 rounded-md border-0 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-[2px] focus:ring-inset" />
    </div>
  </div>
  <div>
    <button 
      type="submit"
      class="w-full rounded-md bg-blue-300 px-3 mt-[8px]"
    >Login</button>
    <a href="/auth/register" class="block text-center mt-[8px]">Register</a>
  </div>
</form>
```

## File: views/auth/register.ejs
```
<!doctype html>
<html lang="en">
  <%- include('../partials/head') %>
  <body class="text-[12px]">
    <div class="container mx-auto">
      <%- include('../partials/menu') %>

      <section>
        <form
          method="post"
          action="/auth/register"
          class="container w-[50%] mx-auto"
        >
          <div class="mb-[8px]">
            <label for="username">Username</label>
            <input
              type="username"
              id="username"
              name="username"
              placeholder="Choose your username"
              required
              class="block w-full px-2 rounded-md border-0 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-[2px] focus:ring-inset"
            />
          </div>
          <div class="mb-[8px]">
            <label for="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              placeholder="you@domain.com"
              required
              class="block w-full px-2 rounded-md border-0 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-[2px] focus:ring-inset"
            />
          </div>
          <div class="mb-[8px]">
            <label for="password">Password</label>
            <input
              type="password"
              id="password"
              name="password"
              required
              class="block w-full px-2 rounded-md border-0 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-[2px] focus:ring-inset"
            />
          </div>
          <div class="mb-[8px]">
            <button
              type="submit"
              class="w-full rounded-md bg-blue-300 px-3 mt-[8px]"
            >
              Register
            </button>
            <a href="/" class="block text-center mt-[8px]">Login</a>
          </div>
        </form>
      </section>
    </div>
  </body>
</html>
```

## File: views/games/game.ejs
```
<!doctype html>
<html lang="en">
  <%- include ('../partials/head') %>
  <body class="text-[12px]">
    <div class="container mx-auto">
      <%- include('../partials/menu') %>

      <div class="flex flex-row">
        <section class="basis-4/6 mr-[20px]">
          <div
            id="opponent-area"
            class="w-[100%] flex flex-row justify-around min-h-[100px]"
          ></div>
          <div id="playing-table">
            <div class="w-[60%] flex flex-row justify-between mx-auto">
              <div
                class="card back"
                id="draw-pile"
                data-game-id="<%= gameId %>"
              ></div>

              <div class="card blank" id="play-pile-n"></div>
              <div class="card blank" id="play-pile-w"></div>
              <div class="card blank" id="play-pile-e"></div>
              <div class="card blank" id="play-pile-s"></div>
            </div>
            <div
              id="player-area"
              class="w-[100%] flex flex-row justify-around"
            ></div>
          </div>
        </section>

        <%- include('./templates') %>
        <script src="/js/main.js"></script>
        <div class="basis-2/6"><%- include('../partials/chat') %></div>
        <script src="/js/games.js"></script>
      </div>
    </div>
  </body>
</html>
```

## File: views/games/lobby.ejs
```
<!doctype html>
<html lang="en">
  <%- include ('../partials/head') %>
  <body class="text-[12px]">
    <div class="container mx-auto">
      <%- include('../partials/menu') %>
      <section>
        <div class="flex flex-row">
          <section class="basis-4/6 mr-[20px]">
            Lobby page for game <%= gameId %>
          </section>
          <div class="basis-2/6"><%- include('../partials/chat') %></div>
        </div>
      </section>

      <%- include('../partials/footer') %>
      <script src="/js/game-lobby.js"></script>
    </div>
  </body>
</html>
```

## File: views/games/templates.ejs
```
<template id="card-template">
  <div class="card">
    <span></span>
  </div>
</template>

<template id="player-template">
  <div class="player mt-[10px] rounded-md p-[10px]">
    <h4 class="flex flex-row justify-start items-center">
      <img class="gravatar w-[20px] h-[20px] rounded-[10px] mx-[10px]" />
      <div class="flex flex-col">
        <span class="username"></span>
        <span class="card-count text-[8px] font-light"></span>
      </div>
    </h4>
    <div class="flex flex-row justify-between">
      <div class="flex flex-row hand scale-75"></div>
      <div class="flex flex-row scale-75">
        <div class="player-pile-0 mr-[8px]">
          <div class="card back"></div>
          <span class="absolute bottom-0 mb-[-20px]"></span>
        </div>
        <div class="player-pile-1 mr-[8px]"></div>
        <div class="player-pile-2 mr-[8px]"></div>
        <div class="player-pile-3 mr-[8px]"></div>
        <div class="player-pile-4"></div>
      </div>
    </div>
  </div>
</template>
```

## File: views/partials/chat.ejs
```
<template id="chat-message-template">
  <li class="chat-message flex flex-row items-center">
    <img class="gravatar w-[16px] h-[16px] rounded-[8px] mr-[4px] self-start" />
    <span class="content text-[8px] text-gray-700"></span>
  </li>
</template>

<aside id="chat-section" class="h-[300px] flex flex-col">
  <ul
    id="messages"
    class="rounded-md border-[1px] border-gray-300 w-full grow p-[4px] overflow-y-auto"
  ></ul>
  <form method="post" class="flex flex-row h-[20px] mt-[8px]">
    <input
      id="chat-message"
      autocomplete="off"
      placeholder="Type your message here"
      class="border-[1px] border-gray-300 mr-[4px] block grow rounded-sm text-[10px] px-1"
    /><button class="w-[30px] text-[8px] bg-blue-200 rounded-sm px-1">
      Send
    </button>
  </form>
</aside>
<script src="/js/chat.js"></script>
```

## File: views/partials/head.ejs
```
<head>
  <link rel="stylesheet" href="css/bundle.css" />

  <title>Yas Kween - <%= title %></title>
  <script src="/js/main.js"></script>
  <script>
    window.roomId = "<%= roomId %>";
  </script>
</head>
```

## File: views/partials/menu.ejs
```
<nav class="pt-[10px] flex flex-row justify-between mb-[20px]" %>">
  <a href="<%= locals.user === undefined ? "/" : "/lobby" %>">
    <img src="/images/logo.webp" alt="logo" class="w-[40px] h-[40px] rounded-[20px]"/>
  </a>
  <% if(locals.user !== undefined) { %>
    <div class="flex flex-row items-center">
      <a href="/logout">Logout</a>
      <img src="https://gravatar.com/avatar/<%= locals.user.gravatar %>" alt="Gravatar of <%= locals.user.username %>" class="w-[40px] h-[40px] rounded-[20px] ml-[10px]"/>
    </div>
  <% } %>
</nav>
```

## File: views/home.ejs
```
<!doctype html>
<html lang="en">
  <%- include('partials/head') %>

  <body class="text-[12px]">
    <div class="container mx-auto">
      <%- include('partials/menu') %>

      <section class="container"><%- include('auth/login') %></section>
    </div>
  </body>
</html>
```

## File: views/main-lobby.ejs
```
<!doctype html>
<html lang="en">
  <%- include('partials/head') %>

  <body class="text-[12px]">
    <div class="container mx-auto">
      <%- include('partials/menu') %>

      <div class="flex flex-row">
        <section class="basis-4/6 mr-[20px]">
          <div class="flex flex-row-reverse mb-[20px]">
            <form method="post" action="/games/create">
              <button class="bg-blue-200 rounded-sm px-1 border-[1px] border-blue-800">Create a new game room</button>
            </form>
          </div>
          <table class="min-w-full">
            <thead>
              <tr>
                <th class="text-left border-b-[1px] border-gray-400 py-[4px]">Room name</th>
                <th class="text-left border-b-[1px] border-gray-400 py-[4px]">Players</th>
                <th class="text-center border-b-[1px] border-gray-400 py-[4px]">Join</th>
              </tr>
            </thead>
            <tbody id="available-games-list">
              <% locals.availableGames !== undefined && availableGames.forEach((room) => { %>
                <tr id="game-row-<%= room.id %>">
                  <td class="border-b-[1px] border-gray-400 py-[4px]">Game <%= room.id %></td>
                  <td class="border-b-[1px] border-gray-400 py-[4px]"><%= room.players %> / <%= room.player_count %></td>
                  <td class="text-center border-b-[1px] border-gray-400 py-[4px]">
                    <form action="/games/join/<%= room.id %>" method="post">
                      <button class="bg-blue-200 rounded-sm px-1 border-[1px] border-blue-800">Join</button>
                    </form>
                  </td>
                </tr>
              <% }); %>
            </tbody>
          </table>
        </section>
        <div class="basis-2/6"><%- include('partials/chat') %></div>
      </div>
    </div>

    <template id="game-row-template">
      <tr>
        <td class="border-b-[1px] border-gray-400 py-[4px]"></td>
        <td class="border-b-[1px] border-gray-400 py-[4px]"></td>
        <td class="text-center border-b-[1px] border-gray-400 py-[4px]">
          <form action="/join/X" method="post">
            <button class="bg-blue-200 rounded-sm px-1 border-[1px] border-blue-800">Join</button>
          </form>
        </td>
      </tr>
    </template>

    <%- include('partials/footer') %>
    <script src="/js/main-lobby.js"></script>
  </body>
</html>
```

## File: index.ts
```typescript
import cookieParser from "cookie-parser";
import dotenv from "dotenv";
import express from "express";
import morgan from "morgan";
import * as path from "path";
import { createServer } from "http";
import { Server, Socket } from "socket.io";
import helmet from "helmet";
import rateLimit from "express-rate-limit";
import cors from "cors";
import { IncomingMessage } from "http";
import { SessionData } from "express-session";
// Extend IncomingMessage to include session
interface SessionIncomingMessage extends IncomingMessage {
  session: SessionData;
}
// Extend Socket type to include session
interface SessionSocket extends Socket {
  request: IncomingMessage & {
    session: SessionData;
  };
}
dotenv.config();
import * as configuration from "./config";
import { errorHandler, notFoundHandler } from "./middleware/error";
import { authenticate, optionalAuthenticate } from "./middleware/auth";
import authRoutes from "./routes/auth";
import mainLobbyRouter from "./routes/main-lobby";
import home from "./routes/home";
const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: process.env.NODE_ENV === "production"
      ? process.env.CORS_ORIGIN
      : "http://localhost:3000",
    credentials: true
  },
  allowEIO3: true,
  pingTimeout: 60000,
  pingInterval: 25000
});
const PORT = process.env.PORT || 3000;
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "ws:", "wss:"],
      fontSrc: ["'self'", "https:", "data:"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'self'"],
    },
  },
}));
app.use(cors({
  origin: process.env.NODE_ENV === "production"
    ? process.env.CORS_ORIGIN
    : "http://localhost:3000",
  credentials: true
}));
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use("/api/", limiter);
app.use(morgan("dev"));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
// Set up view engine
app.set("views", path.join(process.cwd(), "src", "views"));
app.set("view engine", "ejs");
// Serve static files with explicit MIME types
app.use(express.static(path.join(process.cwd(), "src", "public"), {
  setHeaders: (res, path) => {
    if (path.endsWith('.css')) {
      res.setHeader('Content-Type', 'text/css');
    }
  }
}));
// Set up Socket.IO with session support
const sessionMiddleware = configuration.configureSession(app);
const wrap = (middleware: any) => (socket: any, next: any) => middleware(socket.request, {}, next);
io.use(wrap(sessionMiddleware));
io.use((socket, next) => {
  const session = (socket as SessionSocket).request.session;
  console.log('Socket middleware - connection attempt:', {
    socketId: socket.id,
    url: socket.request.headers.referer,
    sessionExists: !!session,
    userExists: !!session?.user,
    username: session?.user?.username,
    cookies: socket.request.headers.cookie
  });
  // More lenient check - allow connection even without session
  if (session && session.user) {
    console.log('Socket authenticated for user:', {
      username: session.user.username,
      socketId: socket.id
    });
    next();
  } else {
    console.log('Socket proceeding without authentication:', {
      socketId: socket.id,
      sessionExists: !!session
    });
    next(); // Allow connection without authentication
  }
});
// Keep track of connected sockets
const connectedSockets = new Set<string>();
io.on("connection", (socket) => {
  const session = (socket as SessionSocket).request.session;
  console.log("Client connected:", {
    socketId: socket.id,
    url: socket.request.headers.referer,
    authenticated: !!session?.user,
    username: session?.user?.username
  });
  connectedSockets.add(socket.id);
  console.log("Total connected clients:", connectedSockets.size);
  // Attach user data to socket
  const user = session?.user;
  socket.data.user = user;
  socket.on("disconnect", (reason) => {
    console.log("Client disconnected:", {
      socketId: socket.id,
      reason,
      url: socket.request.headers.referer,
      authenticated: !!session?.user,
      username: session?.user?.username
    });
    connectedSockets.delete(socket.id);
    console.log("Remaining connected clients:", connectedSockets.size);
  });
  // Add error event handler
  socket.on("error", (error) => {
    console.error("Socket error:", {
      socketId: socket.id,
      error,
      url: socket.request.headers.referer
    });
  });
  // Add connect_error event handler
  socket.on("connect_error", (error) => {
    console.error("Socket connect error:", {
      socketId: socket.id,
      error,
      url: socket.request.headers.referer
    });
  });
  // Game-specific events will be added here
});
app.use("/api/auth", authRoutes);
app.use("/auth", authRoutes);
app.use("/api/games", authenticate, /* games router */);
app.use("/api/users", authenticate, /* users router */);
// Use home router for root path and main-lobby router for /lobby
app.use("/", optionalAuthenticate, home);
app.use("/lobby", authenticate, mainLobbyRouter);
app.use(notFoundHandler);
app.use(errorHandler);
server.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV}`);
});
```
